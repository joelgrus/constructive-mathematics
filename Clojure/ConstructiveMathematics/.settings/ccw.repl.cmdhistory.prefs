cmdhistory=[";; Switching to natural namespace" "(take 10 all-naturals)" "(range one three)" "(is-even two)" "zero" "(ns integers)" "is-even" "(ns integer)" "is-even" "two" "(is-even zero)" "(is-even two)" "(is-odd two)" "(is-odd one)" "(successor-of two)" "(add minus-one two)" "(gcd one two)" "(subtract one two)" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'ConstructiveMathematics.natural-numbers)))" ";; Switching to ConstructiveMathematics.integers namespace" "x" ";; Switching to ConstructiveMathematics.integers namespace" "(range one two)" "one" "two" "one" "two" "three" "four" "five" "minus-one" "(is-divisible-by four two)" "(modulo four two)" "(module two one)" "(modulo two one)" "(modulo zero one)" "module" "modulo" "(less-than zero one)" "(less-than zero minus-one)" "(modulo four two)" "(modulo four three)" "(is-divisible-by four two)" "(range one two)" "(range minus-one four)" "(clojure.core/ns ConstructiveMathematics.rational-numbers)\\n(require '[ConstructiveMathematics.natural-numbers \:as natural-numbers])\\r\\n(require '[ConstructiveMathematics.integers \:as integers])\\r\\n\\n(defn rational [numerator denominator]\\n  (let [gcd (if (integers/equal-to integers/zero denominator)\\n              (throw (Exception. \\"cannot have a zero denominator\!\\"))\\n              (integers/gcd numerator denominator))\\n        re-sign (if (integers/less-than denominator integers/zero)\\n                  integers/negate\\n                  (fn [i] i))]\\n    {\:numerator (integers/divide (re-sign numerator) gcd),\\n     \:denominator (integers/divide (re-sign denominator) gcd)}))\\n(clojure.core/ns ConstructiveMathematics.integers)" "rational?" "rational" "(clojure.core/ns ConstructiveMathematics.rational-numbers)\\n(ns ConstructiveMathematics.rational-numbers)\\n\\n(require '[ConstructiveMathematics.natural-numbers \:as natural-numbers])\\r\\n(require '[ConstructiveMathematics.integers \:as integers])\\r\\n\\n(defn rational [numerator denominator]\\n  (let [gcd (if (integers/equal-to integers/zero denominator)\\n              (throw (Exception. \\"cannot have a zero denominator\!\\"))\\n              (integers/gcd numerator denominator))\\n        re-sign (if (integers/less-than denominator integers/zero)\\n                  integers/negate\\n                  (fn [i] i))]\\n    {\:numerator (integers/divide (re-sign numerator) gcd),\\n     \:denominator (integers/divide (re-sign denominator) gcd)}))\\n(clojure.core/ns ConstructiveMathematics.integers)" "rational?" "ConstructiveMathematics.rational-numbers/rational" "(ConstructiveMathematics.rational-numbers/rational integers/one integers/one)" "(clojure.core/ns ConstructiveMathematics.rational-numbers)\\n(ns ConstructiveMathematics.rational-numbers)\\n\\n(require '[ConstructiveMathematics.natural-numbers \:as natural-numbers])\\r\\n(require '[ConstructiveMathematics.integers \:as integers])\\n(clojure.core/ns ConstructiveMathematics.integers)" "(ConstructiveMathematics.rational-numbers/rational integers/one integers/one)" ";; Switching to ConstructiveMathematics.rational-numbers namespace" "(all-for-total integers/zero)" "(all-for-total integers/one)" "(all-for-total natural-numbers/one)" "(def n \\n  natural-numbers/two))\\n\\nn)\\n)\\n\\n(def n 4)" "(def n natural-numbers/two)" "n" "(def total (integers/positive n))" "total" "(def pre-total (\:predecessor total))" "pre-total" "total" "(def pre-total (\:predecessor (\:n total)))" "pre-total" "(integers/range integers/one pre-total)" "(range one two)" ";; Switching to ConstructiveMathematics.integers namespace" "(range one two)" "(range zero three)" ";; Switching to ConstructiveMathematics.rational-numbers namespace" "(all-for-total natural-numbers/two)" "(all-for-total natural-numbers/one)" "integers/one" ";; Switching to ConstructiveMathematics.rational-numbers namespace" "(natural-numbers/two)" "natural-numbers/two" "(conj natural-numbers/two nil)" "(conj natural-numbers/two ())" ";; Switching to ConstructiveMathematics.rational-numbers namespace" "3" "(all-for-total natural-numbers/two)" ";; Switching to ConstructiveMathematics.integers namespace" "(range one two)" "(range one one)" "(range one three)" "(defn range [lo hi]\\r\\n  (if (less-than hi lo) nil\\r\\n    (cons lo (lazy-seq (range (successor-of lo) hi)))))" "(range one two)" "(range one three)" ";; Switching to ConstructiveMathematics.rational-numbers namespace" "(all-for-total natural-numbers/two)" "(defn all-for-total [n]\\r\\n  (let [total (integers/positive n)\\r\\n        pre-total (\:predecessor (\:n total))]\\r\\n    (->> (integers/range integers/one pre-total)\\r\\n      (map (fn [i] [i (integers/subtract total i)]))\\r\\n      (filter (fn [[i j]] (integers/equal-to integers/one (integers/gcd i j))))\\r\\n      (mapcat (fn [[i j]] [(rational i j) (rational (integers/negate i) j)])))))\\r\\n\\r\\n(all-for-total natural-numbers/two)" ";; Switching to ConstructiveMathematics.rational-numbers namespace" "(all-for-total natural-numbers/two)" "(def n natural-numbers/two)" "(def total (integers/positive n))" "total" "n" ";; Switching to ConstructiveMathematics.rational-numbers namespace" "(def n natural-numbers/two)" "n" "(def total (integers/positive n))" "total" "(def pre-total (\:predecessor (\:n total)))" "pre-total" "(integers/range integers/one pre-total)" ";; Switching to ConstructiveMathematics.integers namespace" "(range one two)" "(range one one)" "(range one zero)" "(range one two)" "(range minus-one four)" ";; Switching to ConstructiveMathematics.rational-numbers namespace" "(all-for-total integers/two)" "(all-for-total integers/three)" "(def n integers/two)" "n" "(all-for-total natural-numbers/two)" "(all-for-total natural-numbers/three)" "(def all-rationals\\r\\n  (conj zero (mapcat all-for-total natural-numbers/all-naturals)))" "(take 10 all-rationals)" ";; Switching to ConstructiveMathematics.rational-numbers namespace" "(take 10 all-rationals)"]
eclipse.preferences.version=1
